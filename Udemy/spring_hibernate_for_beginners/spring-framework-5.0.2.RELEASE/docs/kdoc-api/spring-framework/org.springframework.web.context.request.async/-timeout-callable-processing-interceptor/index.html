<HTML>
<HEAD>
<meta charset="UTF-8">
<title>TimeoutCallableProcessingInterceptor - spring-framework</title>
<link rel="stylesheet" href="../../../style.css">
</HEAD>
<BODY>
<a href="../../index.html">spring-framework</a>&nbsp;/&nbsp;<a href="../index.html">org.springframework.web.context.request.async</a>&nbsp;/&nbsp;<a href=".">TimeoutCallableProcessingInterceptor</a><br/>
<br/>
<h1>TimeoutCallableProcessingInterceptor</h1>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">TimeoutCallableProcessingInterceptor</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">CallableProcessingInterceptor</span></code>
<p>Sends a 503 (SERVICE_UNAVAILABLE) in case of a timeout if the response is not already committed. As of 4.2.8 this is done indirectly by setting the result to an AsyncRequestTimeoutException which is then handled by Spring MVC's default exception handling as a 503 error. 
<p>Registered at the end, after all other interceptors and therefore invoked only if no other interceptor handles the timeout. </p>
<p>Note that according to RFC 7231, a 503 without a 'Retry-After' header is interpreted as a 500 error and the client should not retry. Applications can install their own interceptor to handle a timeout and add a 'Retry-After' header if necessary.</p>
</p>
<p><strong>Author</strong><br/>
Rossen Stoyanchev</p>
<p><strong>Since</strong><br/>
3.2</p>
<h3>Constructors</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="-init-.html">&lt;init&gt;</a></p>
</td>
<td>
<code><span class="identifier">TimeoutCallableProcessingInterceptor</span><span class="symbol">(</span><span class="symbol">)</span></code>
<p>Sends a 503 (SERVICE_UNAVAILABLE) in case of a timeout if the response is not already committed. As of 4.2.8 this is done indirectly by setting the result to an AsyncRequestTimeoutException which is then handled by Spring MVC's default exception handling as a 503 error. 
<p>Registered at the end, after all other interceptors and therefore invoked only if no other interceptor handles the timeout. </p>
<p>Note that according to RFC 7231, a 503 without a 'Retry-After' header is interpreted as a 500 error and the client should not retry. Applications can install their own interceptor to handle a timeout and add a 'Retry-After' header if necessary.</p>
</p>
</td>
</tr>
</tbody>
</table>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<p><a href="handle-timeout.html">handleTimeout</a></p>
</td>
<td>
<code><span class="keyword">open</span> <span class="keyword">fun </span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a><span class="symbol">&gt;</span> <span class="identifier">handleTimeout</span><span class="symbol">(</span><span class="identifier" id="org.springframework.web.context.request.async.TimeoutCallableProcessingInterceptor$handleTimeout(org.springframework.web.context.request.NativeWebRequest, java.util.concurrent.Callable((org.springframework.web.context.request.async.TimeoutCallableProcessingInterceptor.handleTimeout.T)))/request">request</span><span class="symbol">:</span>&nbsp;<span class="identifier">NativeWebRequest</span><span class="symbol">, </span><span class="identifier" id="org.springframework.web.context.request.async.TimeoutCallableProcessingInterceptor$handleTimeout(org.springframework.web.context.request.NativeWebRequest, java.util.concurrent.Callable((org.springframework.web.context.request.async.TimeoutCallableProcessingInterceptor.handleTimeout.T)))/task">task</span><span class="symbol">:</span>&nbsp;<span class="identifier">Callable</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/index.html"><span class="identifier">Any</span></a></code></td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
